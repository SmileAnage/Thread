Thread多线程
===

[TOC]

### 线程基本概念
* 什么是线程
>* 线程被称为轻量级的进程
>* 线程也可以使用计算机多核资源，是多任务编程方式
>* 线程是系统分配内核的最小单元
>* 线程可以理解为进程的分支任务

* 线程特征
>* 一个进程中可以包含多个线程
>* 线程也是一个运行行为，消耗计算机资源
>* 一个进程中的所有线程共享这个进程的资源
>* 多个线程之间的运行互不影响各自运行
>* 线程的创建和销毁消耗资源远小于进程
>* 各个线程也有自己的ID等特征

### threading模块创建线程
* 基本流程
***参考代码thread01.py***
* 线程函数传参
```
from threading import Thread

t = Thread()  # 创建线程
参数：target 绑定线程函数
	  args    元组 给线程函数位置传参
	  kwargs  字典 给线程函数位置传参
t.start()  # 启动线程
t.join()  # 回收线程
```
***参考代码thread02.py***
### 自定义线程类
* 创建步骤
>* 继承Thread类
>* 重写__init__()方法增加自己的属性，使用super加载父类属性
>* 重写run()方法

* 使用方法
>* 实例化对象
>* 调用start自动执行run方法
>* 调用join回收线程

***参考代码thread03.py***
### 同步互斥
#### 线程间通信方法
* 通信方式：线程间使用全局变量进行通信
* 资源共享：多个进程或者线程都可以操作的资源称为共享资源．对共享资源的操作代码段称为临界点
* 影响：对共享资源的无序操作可能会带来数据的混乱，或者操作错误．此时往往需要同步互斥机制协调操作顺序
* 同步互斥机制
>* 同步：同步是一种协作关系，未完成操作，多进程或者线程间形成一种协调．按照必要的步骤有序执行操作
>* 互斥：互斥是一种制约关系，当一个进程或者线程占有资源时会进行加锁处理，此时其他进程就无法操作该资源，直到解锁后才能操作
#### 线程同步互斥方法
#### 线程Event
```
from threading import Event

e = Event  # 创建线程event对象
e.wait()  # 阻塞等待e被set
e.set()  # 设置e,使wait结束阻塞
e.clear()  # 使e回到未被设置状态
e.is_set()  # 查看当前e是否被设置
```
***参考代码thread_event.py***
#### 线程锁Lock
```
from threading import Lock

lock = Lock()  # 创建锁对象
lock.acquire()  # 上锁 如果lock已经上锁在调用会阻塞
lock.release()  # 解锁

# 自动锁，结束时自动解锁
with lock:  # 上锁
	...
	...
		#结束自动解锁
```
***参考代码thread_lock.py***
#### 死锁及处理
* 死锁是指两个或两个以上的线程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法继续下去．此时称系统处于死锁状态或系统产生了死锁
* 死锁产生条件
>* 死锁发生的必要条件
>>* 互斥条件：指线程对所分配到的资源进行排它性使用，即在一段时间内某资源只有一个进程占用．如果此时还有其他进程请求资源，则请求者只能等待，直至占用资源的进程用毕释放
>>* 请求和保持条件：指线程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求线程阻塞，但又对自己已获得的其他资源保持不放
>>* 不剥夺条件：指线程已获得的字眼，在未使用完之前，不能被剥夺，只能在使用完时由自己释放，通常CPU内存资源是可以被系统强行调配剥夺的
>>* 环路等待条件：指在发生死锁时，必然存在一个线程--资源的环形链，即进程集合{T0,T1,T2}中的T0正在等待一个T1占用的资源；T1正在等待T2占用的资源．．．
>* 死锁的产生原因
>>* 当前线程拥有其他线程需要的资源
>>* 当前线程等待其他线程已拥有的资源
>>* 都不放弃自己已拥有的资源

* 如何避免死锁
死锁是我们非常不愿意看到的一种现象，我们尽可能避免死锁的发生．通常设置某些限制条件，去破坏产生死锁的四个必要条件中的一个或者多个，来预防发生死锁．预防死锁是一种较易实现的方法，但是由于所施加的限制条件往往太严格，可能会破坏系统资源利用率
#### python线程GIL
* python线程的GIL问题 （全局解释器锁）
>* 什么是GIL ：由于python解释器设计中加入了解释器锁，导致python解释器同一时刻只能解释执行一个线程，大大降低了线程的执行效率。
>* 导致后果： 因为遇到阻塞时线程会主动让出解释器，去解释其他线程。所以python多线程在执行多阻塞高延迟IO时可以提升程序效率，其他情况并不能对效率有所提升。
>* GIL问题建议
>>* 尽量使用进程完成无阻塞的并发行为
>>* 不使用c作为解释器 （Java  C#）

* 结论 ： 在无阻塞状态下，多线程程序和单线程程序执行效率几乎差不多，甚至还不如单线程效率。但是多进程运行相同内容却可以有明显的效率提升。
























